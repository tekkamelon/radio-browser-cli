#!/usr/bin/env python3
"""
Radio Browser CLI - MPD対応ウェブラジオ検索ツール
Radio-Browser.info APIを使用してラジオ局を検索し,MPDで再生可能な形式で出力
"""

# HTTPリクエストを送信するためのライブラリ
import requests
# JSONデータを処理するためのライブラリ
import json
# コマンドライン引数を解析するためのライブラリ
import argparse
# システム固有のパラメータと関数にアクセスするためのライブラリ
import sys
# 型ヒントのためのライブラリ
import typing
# 環境変数とログのためのライブラリ
import os
import logging

# 環境変数からの設定
API_TIMEOUT = int(os.getenv('RADIO_BROWSER_TIMEOUT', '10'))

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class RadioBrowserCLI:
    def __init__(self):
        """初期化メソッド。APIのベースURLとセッションを設定"""
        # セッションオブジェクトを作成
        self.session = requests.Session()
        # リクエストヘッダーを更新
        self.session.headers.update({
            # ユーザーエージェントを設定
            'User-Agent': 'RadioBrowserCLI/1.0'
        })
        # Radio-Browser APIのベースURLリスト（フェイルオーバー用、DNS TXTから動的取得）
        self.api_urls = self._get_api_servers()

        self.current_base_url = None

    def _get_api_servers(self):
        """APIサーバーリストをDNS経由で動的に取得"""
        try:
            # 方法1: 直接all.api.radio-browser.infoにアクセスして利用可能なサーバーリストを取得
            print("APIサーバーリストを取得中...", file=sys.stderr)
            response = self.session.get(
                "https://all.api.radio-browser.info/json/servers",
                timeout=5
            )
            response.raise_for_status()
            servers_data = response.json()

            servers = []
            for server in servers_data:
                server_name = server.get('name', '')
                if server_name:
                    # サーバー名からURLを構築
                    server_url = f"https://{server_name}/json"
                    servers.append(server_url)

            if servers:
                print(f"{len(servers)}個のAPIサーバーを取得しました。", file=sys.stderr)
                return servers
            else:
                raise ValueError("サーバーリストが空です")

        except Exception as e:
            print(f"APIサーバーリスト取得失敗: {e}", file=sys.stderr)
            print("フォールバックサーバーリストを使用します。", file=sys.stderr)

        # フォールバックサーバーリスト
        fallback_servers = [
            "https://de1.api.radio-browser.info/json",
            "https://de2.api.radio-browser.info/json",
            "https://fi1.api.radio-browser.info/json",
            "https://fr1.api.radio-browser.info/json",
            "https://nl1.api.radio-browser.info/json",
        ]
        return fallback_servers

    def _api_get(
        self,
        endpoint: str,
        params: typing.Optional[dict] = None,
        timeout: int = API_TIMEOUT
    ) -> typing.Optional[requests.Response]:
        """プライベートメソッド。APIリクエストを複数のURLでフェイルオーバー実行"""
        for base_url in self.api_urls:
            try:
                response = self.session.get(
                    f"{base_url}/{endpoint}",
                    params=params,
                    timeout=timeout
                )
                response.raise_for_status()
                self.current_base_url = base_url
                logger.info(f"APIリクエスト成功: {base_url}/{endpoint}")
                return response
            except requests.RequestException as e:
                logger.warning(f"{base_url} に接続失敗: {e}")
                continue
        logger.error("すべてのAPIエンドポイントが失敗しました。")
        return None

    def search_stations(
        self,
        name: typing.Optional[str] = None,
        country: typing.Optional[str] = None,
        tag: typing.Optional[str] = None,
        language: typing.Optional[str] = None,
        limit: int = 20
    ) -> typing.List[dict]:
        """ラジオ局を検索するメソッド
        Args:
            name: ラジオ局名
            country: 国名
            tag: タグ
            language: 言語
            limit: 結果数制限
        Returns:
            list: 検索結果のラジオ局リスト
        """
        # APIリクエストのパラメータを格納する辞書
        params = {}
        if name:
            params['name'] = name
        if country:
            params['country'] = country
        if tag:
            params['tag'] = tag
        if language:
            params['language'] = language
        params['limit'] = limit
        # 動作していない局を非表示にする
        params['hidebroken'] = 'true'
        # APIリクエストを送信
        response = self._api_get("stations/search", params=params)
        if response:
            return response.json()
        else:
            return []

    def get_countries(
        self,
        limit: typing.Optional[int] = None
    ) -> typing.List[dict]:
        """利用可能な国のリストを取得するメソッド
        Args:
            limit: 取得する国の最大数
        Returns:
            list: 国のリスト
        """
        params = {}
        if limit:
            params['limit'] = limit
        response = self._api_get("countries", params=params)
        if response:
            return response.json()
        else:
            return []

    def get_tags(
        self,
        limit: typing.Optional[int] = None
    ) -> typing.List[dict]:
        """利用可能なタグのリストを取得するメソッド
        Args:
            limit: 取得するタグの最大数
        Returns:
            list: タグのリスト
        """
        params = {}
        if limit:
            params['limit'] = limit
        response = self._api_get("tags", params=params)
        if response:
            return response.json()
        else:
            return []

    def _format_station_line(
        self,
        station: dict,
        format_type: str,
        index: int
    ) -> str:
        """ラジオ局を指定された形式の行にフォーマットするヘルパーメソッド"""
        name = station.get('name', 'N/A')
        country = station.get('country', 'N/A')
        tags = station.get('tags', 'N/A')
        url = station.get('url_resolved', station.get('url', 'N/A'))
        bitrate = station.get('bitrate', 'N/A')
        codec = station.get('codec', 'N/A')

        if format_type == 'csv':
            name = name.replace(',', ';').replace('"', "'")
            tags = tags.replace(',', ';')
            return f"{index},{name},{country},{tags},{bitrate},{codec},{url}"
        elif format_type == 'tsv':
            name = name.replace('\t', ' ')
            tags = tags.replace('\t', ' ')
            return (
                f"{index}\t{name}\t{country}\t{tags}\t{bitrate}\t{codec}"
                f"\t{url}"
            )
        else:
            raise ValueError(f"サポートされていないフォーマット: {format_type}")

    def _is_valid_url(self, url: str) -> bool:
        """URLが有効かをチェックするヘルパーメソッド"""
        from urllib.parse import urlparse
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except Exception:
            return False

    def display_stations(
        self,
        stations: typing.List[dict],
        format_type: str = 'csv'
    ) -> None:
        """検索結果を指定された形式で表示するメソッド
        Args:
            stations: ラジオ局のリスト
            format_type: 出力形式（csv, tsv, urls, json, m3u）
        """
        # ラジオ局が存在しない場合
        if not stations:
            # エラーメッセージを表示
            logger.warning("検索結果が見つかりませんでした。")
            return

        # CSV形式の場合
        if format_type in ('csv', 'tsv'):
            for i, station in enumerate(stations):
                print(self._format_station_line(station, format_type, i+1))

        # URLのみの場合
        elif format_type == 'urls':
            # 各ラジオ局について
            for station in stations:
                # URLを取得
                url = station.get('url_resolved', station.get('url', ''))
                # URLが存在し、有効な場合
                if url and self._is_valid_url(url):
                    # URLを出力
                    print(url)

        # JSON形式の場合
        elif format_type == 'json':
            # JSON形式で出力（日本語対応）
            print(json.dumps(stations, indent=2, ensure_ascii=False))

        # M3Uプレイリスト形式の場合
        elif format_type == 'm3u':
            # プレイリストヘッダーを出力
            print("#EXTM3U")
            # 各ラジオ局について
            for station in stations:
                # 名前を取得（デフォルトは'Unknown'）
                name = station.get('name', 'Unknown')
                # URLを取得
                url = station.get('url_resolved', station.get('url', ''))
                # URLが存在し、有効な場合
                if url and self._is_valid_url(url):
                    # 拡張情報行を出力
                    print(f"#EXTINF:-1,{name}")
                    # URLを出力
                    print(url)
        else:
            logger.error(f"サポートされていないフォーマット '{format_type}'")
            print("利用可能なフォーマット: csv, tsv, urls, json, m3u", file=sys.stderr)


def main():
    """メイン関数。コマンドライン引数を解析し,対応する処理を実行"""
    # 引数パーサーを作成
    # 説明文を設定
    parser = argparse.ArgumentParser(
        description='Radio-Browser.info APIを使用したラジオ局検索ツール',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使い方
======

ラジオ局を検索する (search)
---------------------------

基本コマンド:
  radio-browser-cli search [オプション]

オプション:
  --name NAME         ラジオ局名で検索
  --country COUNTRY   国名で検索 (例: "Japan")
  --tag TAG           ジャンル/タグで検索 (例: "jazz")
  --language LANGUAGE 言語で検索 (例: "japanese")
  --limit LIMIT       結果の最大表示数 (デフォルト: 20)
  --format {csv,tsv,urls,json,m3u}  出力形式 (デフォルト: csv)

使用例:
  名前で検索 (例: "BBC"):
    radio-browser-cli search --name "BBC"

  国とタグで検索し、M3U形式で出力:
    radio-browser-cli search --country "France" \
                             --tag "chanson" \
                             --limit 10 \
                             --format m3u

利用可能な国の一覧を表示する (countries)
---------------------------------------
  radio-browser-cli countries
  --limit LIMIT       表示数の上限を指定できます (デフォルト: 50)

利用可能なタグの一覧を表示する (tags)
------------------------------------
  radio-browser-cli tags
  --limit LIMIT       表示数の上限を指定できます (デフォルト: 50)"""
    )
    # サブコマンド用のパーサーを追加
    subparsers = parser.add_subparsers(dest='command', help='利用可能なコマンド')
    # search コマンド
    # searchサブコマンドのパーサーを作成
    search_parser = subparsers.add_parser('search', help='ラジオ局を検索')
    # 名前検索オプション
    search_parser.add_argument('--name', help='ラジオ局名で検索')
    # 国検索オプション
    search_parser.add_argument('--country', help='国で検索')
    # タグ検索オプション
    search_parser.add_argument('--tag', help='ジャンル/タグで検索')
    # 言語検索オプション
    search_parser.add_argument('--language', help='言語で検索')
    # 結果数制限オプション
    search_parser.add_argument(
        '--limit', type=int, default=20, help='結果数の上限 (デフォルト: 20)'
    )
    # 出力形式オプション
    search_parser.add_argument(
        '--format', choices=['csv', 'tsv', 'urls', 'json', 'm3u'],
        default='csv', help='出力形式 (デフォルト: csv)')
    # countries コマンド
    # countriesサブコマンドのパーサーを作成
    countries_parser = subparsers.add_parser('countries', help='利用可能な国のリストを表示')
    # 表示数制限オプション
    countries_parser.add_argument(
        '--limit', type=int, default=50, help='表示数の上限'
    )
    # tags コマンド
    # tagsサブコマンドのパーサーを作成
    tags_parser = subparsers.add_parser('tags', help='利用可能なタグのリストを表示')
    # 表示数制限オプション
    tags_parser.add_argument('--limit', type=int, default=50, help='表示数の上限')
    # 引数を解析
    args = parser.parse_args()
    # コマンドが指定されていない場合
    if not args.command:
        # ヘルプを表示
        parser.print_help()
        # 終了
        return
    # RadioBrowserCLIインスタンスを作成
    cli = RadioBrowserCLI()
    # searchコマンドの場合
    if args.command == 'search':
        # ラジオ局を検索
        stations = cli.search_stations(
            name=args.name,
            country=args.country,
            tag=args.tag,
            language=args.language,
            limit=args.limit
        )
        # 結果を表示
        cli.display_stations(stations, args.format)
    # countriesコマンドの場合
    elif args.command == 'countries':
        # 国リストを取得
        countries = cli.get_countries(limit=args.limit)
        # ヘッダーを出力
        print("利用可能な国:")
        # 取得した国について繰り返す
        for country in countries:
            # 国名と局数を出力
            print(
                f"  {country.get('name', 'N/A')} "
                f"({country.get('stationcount', 0)} 局)"
            )
        # tagsコマンドの場合
    elif args.command == 'tags':
        # タグリストを取得
        tags = cli.get_tags(limit=args.limit)
        # ヘッダーを出力
        print("利用可能なタグ:")
        # 取得したタグについて繰り返す
        for tag in tags:
            # タグ名から前後の引用符を削除
            tag_name = tag.get('name', 'N/A').strip('"\'') or 'N/A'
            # タグ名と局数を出力
            print(
                f"  {tag_name} "
                f"({tag.get('stationcount', 0)} 局)"
            )


# スクリプトが直接実行された場合
if __name__ == '__main__':
    # メイン関数を呼び出す
    main()
